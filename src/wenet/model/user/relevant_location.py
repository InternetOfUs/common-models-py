from __future__ import absolute_import, annotations

from typing import Optional

from wenet.model.extended_property import ExtendedProperty


class RelevantLocation(ExtendedProperty):

    def __init__(self, location_id: str, label: Optional[str], latitude: Optional[float], longitude: Optional[float]) -> None:
        """
        A location of interest for the user - may be the home or work location -. This information is generated by the platform AI.

        Args:
            location_id: The identifier of the location
            label: The descriptor of the location
            latitude: The latitude of the location (minimum: -90, maximum: 90)
            longitude: The latitude of the location (minimum: -180, maximum: 180)
        """
        self.location_id = location_id
        self.label = label
        self.latitude = latitude
        self.longitude = longitude

        if self.latitude is not None and not (-90 <= self.latitude <= 90):
            raise ValueError("latitude value is not between -90 and 90")

        if self.longitude is not None and not (-180 <= self.longitude <= 180):
            raise ValueError("longitude value is not between -180 and 180")

    def to_repr(self) -> dict:
        return {
            "id": self.location_id,
            "label": self.label,
            "latitude": self.latitude,
            "longitude": self.longitude
        }

    @staticmethod
    def from_repr(raw_data: dict) -> RelevantLocation:
        return RelevantLocation(
            location_id=raw_data["id"],
            label=raw_data.get("label", None),
            latitude=raw_data.get("latitude", None),
            longitude=raw_data.get("longitude", None)
        )

    def __eq__(self, o) -> bool:
        if not isinstance(o, RelevantLocation):
            return False
        return self.location_id == o.location_id and self.label == o.label and self.latitude == o.latitude and self.longitude == o.longitude
